diff --git a/internal/goofys.go b/internal/goofys.go
index b6f95fc..8ad7b4e 100644
--- a/internal/goofys.go
+++ b/internal/goofys.go
@@ -129,51 +129,52 @@ func NewGoofys(bucket string, awsConfig *aws.Config, flags *FlagStorage) *Goofys
 
 	fs.awsConfig = awsConfig
 	fs.sess = session.New(awsConfig)
-	fs.s3 = fs.newS3()
-
-	var isAws bool
-	var err error
-	if !fs.flags.RegionSet {
-		err, isAws = fs.detectBucketLocationByHEAD()
-		if err == nil {
-			// we detected a region header, this is probably AWS S3,
-			// or we can use anonymous access, or both
-			fs.sess = session.New(awsConfig)
-			fs.s3 = fs.newS3()
-		} else if err == fuse.ENOENT {
-			log.Errorf("bucket %v does not exist", fs.bucket)
-			return nil
-		} else {
-			// this is NOT AWS, we expect the request to fail with 403 if this is not
-			// an anonymous bucket, or if the provider doesn't support v4 signing, or both
-			// swift3 and ceph-s3 return 400 so we know we can fallback to v2 signing
-			// minio returns 403 because we are using anonymous credential
-			if err == fuse.EINVAL {
-				fs.fallbackV2Signer()
-			} else if err != syscall.EACCES {
-				log.Errorf("Unable to access '%v': %v", fs.bucket, err)
-			}
-		}
-	}
+//	fs.s3 = fs.newS3()
+
+//	var isAws bool
+//	var err error
+//	if !fs.flags.RegionSet {
+//		err, isAws = fs.detectBucketLocationByHEAD()
+//		if err == nil {
+//			// we detected a region header, this is probably AWS S3,
+//			// or we can use anonymous access, or both
+//			fs.sess = session.New(awsConfig)
+//			fs.s3 = fs.newS3()
+//		} else if err == fuse.ENOENT {
+//			log.Errorf("bucket %v does not exist", fs.bucket)
+//			return nil
+//		} else {
+//			// this is NOT AWS, we expect the request to fail with 403 if this is not
+//			// an anonymous bucket, or if the provider doesn't support v4 signing, or both
+//			// swift3 and ceph-s3 return 400 so we know we can fallback to v2 signing
+//			// minio returns 403 because we are using anonymous credential
+//			if err == fuse.EINVAL {
+//				fs.fallbackV2Signer()
+//			} else if err != syscall.EACCES {
+//				log.Errorf("Unable to access '%v': %v", fs.bucket, err)
+//			}
+//		}
+//	}
+	fs.fallbackV2Signer()
 
 	// try again with the credential to make sure
-	err = mapAwsError(fs.testBucket())
-	if err != nil {
-		if !isAws {
-			// EMC returns 403 because it doesn't support v4 signing
-			// Amplidata just gives up and return 500
-			if err == syscall.EACCES || err == syscall.EAGAIN {
-				fs.fallbackV2Signer()
-				err = mapAwsError(fs.testBucket())
-			}
-		}
-
-		if err != nil {
-			log.Errorf("Unable to access '%v': %v", fs.bucket, err)
-			return nil
-		}
-	}
-
+//	err = mapAwsError(fs.testBucket())
+//	if err != nil {
+//		if !isAws {
+//			// EMC returns 403 because it doesn't support v4 signing
+//			// Amplidata just gives up and return 500
+//			if err == syscall.EACCES || err == syscall.EAGAIN {
+//				fs.fallbackV2Signer()
+//				err = mapAwsError(fs.testBucket())
+//			}
+//		}
+//
+//		if err != nil {
+//			log.Errorf("Unable to access '%v': %v", fs.bucket, err)
+//			return nil
+//		}
+//	}
+//
 	go fs.cleanUpOldMPU()
 
 	if flags.UseKMS {
diff --git a/internal/v2signer.go b/internal/v2signer.go
index c832146..53174c6 100644
--- a/internal/v2signer.go
+++ b/internal/v2signer.go
@@ -39,7 +39,7 @@ var (
 const (
 	signatureVersion = "2"
 	signatureMethod  = "HmacSHA1"
-	timeFormat       = "Mon, 2 Jan 2006 15:04:05 +0000"
+	timeFormat       = "Mon, 02 Jan 2006 15:04:05 +0000"
 )
 
 var subresources = []string{
